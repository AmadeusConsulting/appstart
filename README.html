<!DOCTYPE html>
<html>
  <h1>Appstart Manual</h1>

  <h2>by: gouzenko</h2>


  <h2>Introduction</h2>
  <p>
    Appstart is a tool that allows Managed VM applications to be deployed
    locally for testing purposes. It mimics the current "gcloud preview app
    run" command for managed vms, with a few notable exceptions. Firstly,
    devappserver does not run the application. Instead, dev_appserver runs
    standalone, only starting the API server. It hooks up to the application
    via the --external_port flag. Secondly, devappserver runs inside a
    container. No health checking (as of now) is being performed on the
    application container. The purpose of appstart is to provide a way for
    custom runtime VMs to be started locally after the docker library is
    removed from devappserver.
  </p>
  <p>
    This is not an official Google product (experimental or otherwise), it is
    just code that happens to be owned by Google.
  </p>
  <h2>Installation</h2>
  <p>
    From its root directory, appstart can be installed like so:
  </p>
  <p>
    <pre>
      $ python setup.py sdist
      $ sudo pip install dist/appstart-0.8.tar.gz
    </pre>
  </p>
  <h2>Requirements</h2>
  <p>
    It is required that the user have a Docker client running, interfacing
    with the boot2docker vm. Appstart is known to work for Docker api version
    1.19 (the latest version). For instructions on installing these things see:
  </p>
  <ul>
    <li>docker: https://docs.docker.com/installation/</li>
    <li>boot2docker: http://boot2docker.io/</li>
  </ul>
  <h2>Usage</h2>
  <p>
    Before using appstart for the first time, generate a devappserver base
    image like this:
  </p>
  <p><pre>$ appstart init</pre></p>

  <p>
    For a list of permissible command line options, you can run:
  </p>
  <pre>$ appstart --help</pre>

  <h3>Default invocation</h3>
  <p>
    The appstart script can be use to start the application from the command
    line. It is invoked as follows:
  </p>
  <p><pre>$ appstart PATH_TO_CONFIG_FILE</pre></p>

  <p>
    PATH_TO_CONFIG_FILE must be a path to the application's configuration
    file, which is either 'appengine-web.xml' or a .yaml file. For Java
    standard runtime applications, the 'appengine-web.xml' file must be inside
    WEB-INF, along with a web.xml file. For all other applications, the .yaml
    file must be in the root directory. By default, Appstart will attempt
    to locate the Dockerfile in the application's root directory and use it to
    build the application's image.
  </p>
  <p>
    Furthermore, Appstart will run an api server, simulating the Google Cloud
    Platform's services. It will invoke this api server using the
    application's configuration file.
  </p>

  <h3>Specifying an image</h3>
  <p>
    The --image_name flag can be used to specify an existing image rather than
    having Appstart build one from the Dockerfile. When --image_name is
    specified, a Dockerfile is not needed:
  </p>
  <p><pre>$ appstart PATH_TO_CONFIG_FILE --image_name=IMAGE_NAME</pre></p>

  Appstart can also start an image without a configuration file like so:

  <p><pre>$ appstart --image_name=IMAGE_NAME</pre></p>

  In this case, appstart uses a "phony" app.yaml file as the application's
  configuration file.

  <h3>Turning off the api server</h3>
  <p>
    By default, Appstart runs an api server so that the application can make
    calls to Google Cloud Platform services (datastore, taskqueue, logging,
    etc). If you don't consume these services, you can run appstart like
    this:
  </p>
  <p><pre>$ appstart PATH_TO_CONFIG_FILE --run_api_server=false</pre></p>
  <h2>Other Options</h2>
  <h3>Ports</h3>
  <p>
    By default, Appstart makes the user's application accessible on the docker
    host machine through port 8080, and the admin panel accessible through port
    8000. These defaults can be overidden with the --application_port and --admin_port
    options, respectively.
  </p>
  <h3>Application ID</h3>
    Appstart can be invoked with an application ID using the --application_id option.
    This ID should be the same as the Google App Engine ID found on the Google
    Developers Console. In practice though, this ID can be arbitrarily chosen
    during development. It's important to realize that the application's ID
    determines which api storage files the application has access to. In
    other words, if Appstart is invoked once with --application_id=foo, it must
    be invoked with --application_id=foo in the future for the datastore, taskqueue,
    etc to persist. By default, Appstart chooses a new, timestamped ID during every
    invocation. Therefore, by default, the state of the api services does not persist.
  <h3>Logging</h3>
  <p>
    Managed VM applications are expected to write logs to /var/log/app_engine.
    Appstart provides volume-binding functionality to bind the /var/log/app_engine
    directory inside the application container to a directory on the machine hosting
    the docker server. In the typical setup, this is likely a boot2docker vm. By
    default, Appstart creates a timestamped log directory in /tmp/log/app_engine
    every time it's invoked. This default can be overidden by specifying a log
    directory with the --log_path option.
  </p>
  <h3>Storage path</h3>
  <p>
    The api server creates files to store the state of the application's
    datastore, taskqueue, etc. These files are by default stored in
    /tmp/app_engine/storage on the docker host. An alternative storage
    path can be specified with the --storage_path option.
  </p>
  <h3>Caching during docker builds</h3>
  <p>
    By default, when the application image is built, docker's cache is used.
    To disable the use of docker's cache, set --use_cache=false.
  </p>
  <h3>Timeout</h3>
  <p>
    The --timeout option specifies how long Appstart is willing to wait for the
    application to start listening on port 8080. By default, the timeout is
    30 seconds.
  </p>
  <h2>Under the hood</h2>
  <p>
    Appstart runs the aforementioned api server in the devappserver container.
    The <pre style="display:inline">appstart init</pre> command builds the 'devappserver base image', which
    contains all the source files necessary for the api server to run.
  </p>
  <p>
    Appstart will also build a layer on top of the devappserver image,
    populating the devappserver image with the application's configuration
    files. As was mentioned earlier, if Appstart is not provided with a
    configuration file, it adds a "phony" app.yaml file to the devappserver
    base image.
  </p>
  <p>
    After building images for devappserver and the application, appstart will
    start containers based on these images, using the correct environment
    variables. The environment variables allow the application container to
    locate the devappserver container, and allow the devappserver container to
    locate the application container. The containers currently run on the same
    network stack for simplicity, but that's subject to change in the future.
  </p>
  <p>
    All of the functionality described above is implemented by the
    ContainerSandbox class. This class constructs a sandbox consisting of an
    application container and a devappserver container, and it connects the two
    together. Upon exiting, it will stop these containers and remove them. It's
    quite resilient, so it won't litter the docker environment with old
    containers.
  </p>
</html>
